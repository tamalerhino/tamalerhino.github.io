<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Docker Desktop WSL2 Deep Dive" /><meta property="og:locale" content="en" /><meta name="description" content="In the last few years theres been a big push for Docker Desktop on developer workstations, many of those workstations being Mac and Windows not Linux. But since containers need a Linux kernel to run how does Docker Desktop handle this? Unfortunately the documentation out there is very light particularly using WSL2 so i have taken the time to do research and document my findings." /><meta property="og:description" content="In the last few years theres been a big push for Docker Desktop on developer workstations, many of those workstations being Mac and Windows not Linux. But since containers need a Linux kernel to run how does Docker Desktop handle this? Unfortunately the documentation out there is very light particularly using WSL2 so i have taken the time to do research and document my findings." /><link rel="canonical" href="https://tamalerhino.github.io/posts/docker-desktop-wsl2-deep-dive/" /><meta property="og:url" content="https://tamalerhino.github.io/posts/docker-desktop-wsl2-deep-dive/" /><meta property="og:site_name" content="Tamalerhino’s Blog" /><meta property="og:image" content="https://tamalerhino.github.io/pexels-pia-3046637.jpg" /><meta property="og:image:height" content="800" /><meta property="og:image:width" content="1000" /><meta property="og:image:alt" content="Dive" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-01T12:00:00-05:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://tamalerhino.github.io/pexels-pia-3046637.jpg" /><meta name="twitter:image:alt" content="Dive" /><meta property="twitter:title" content="Docker Desktop WSL2 Deep Dive" /><meta name="twitter:site" content="@tamalerhino" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-10T22:28:50-05:00","datePublished":"2021-10-01T12:00:00-05:00","description":"In the last few years theres been a big push for Docker Desktop on developer workstations, many of those workstations being Mac and Windows not Linux. But since containers need a Linux kernel to run how does Docker Desktop handle this? Unfortunately the documentation out there is very light particularly using WSL2 so i have taken the time to do research and document my findings.","headline":"Docker Desktop WSL2 Deep Dive","image":{"width":1000,"height":800,"alt":"Dive","url":"https://tamalerhino.github.io/pexels-pia-3046637.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tamalerhino.github.io/posts/docker-desktop-wsl2-deep-dive/"},"url":"https://tamalerhino.github.io/posts/docker-desktop-wsl2-deep-dive/"}</script><title>Docker Desktop WSL2 Deep Dive | Tamalerhino's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Tamalerhino's Blog"><meta name="application-name" content="Tamalerhino's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/tamalerhino2-1mb.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Tamalerhino's Blog</a></div><div class="site-subtitle font-italic">Just one rhino's thoughts.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/tamalerhino" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/tamalerhino" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/ulises-galeano/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Docker Desktop WSL2 Deep Dive</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Docker Desktop WSL2 Deep Dive</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1633107600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 1, 2021 </em> </span> <span> Updated <em class="" data-ts="1657510130" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 10, 2022 </em> </span><div class="mt-3 mb-3"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1000 800'%3E%3C/svg%3E" data-src="/assets/img/posts/pexels-pia-3046637.jpg" class="preview-img bg" alt="Dive" width="1000" height="800" data-proofer-ignore><figcaption class="pt-2 pb-2">Dive</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/tamalerhino">Ulises Galeano</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4888 words"> <em>27 min</em> read</span></div></div></div><div class="post-content"><p>In the last few years theres been a big push for Docker Desktop on developer workstations, many of those workstations being Mac and Windows not Linux. But since containers need a Linux kernel to run how does Docker Desktop handle this? Unfortunately the documentation out there is very light particularly using WSL2 so i have taken the time to do research and document my findings.</p><h1 id="wsl2-deep-dive">WSL2 Deep Dive</h1><h2 id="windows-history"><span class="mr-2">Windows History</span><a href="#windows-history" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Before we talk about WSL it’s important to understand a bit about Windows, specifically Windows NT(kernel) and its subsystems. Since the beginning, Windows was designed with the ability to use several different subsystems such as POSIX, OS/2, and Win32 which is the most commonly used one today. This would give a programmatic interface to the applications without having to worry about how to implement them in the WindowsNT kernel itself.</p><p>Each subsystem was implemented as “user mode” modules that issued appropriate NT system calls based on the API they presented to the applications for that subsystem. All applications were PE/COFF executables, a set of libraries and services to implement the subsystem API, and NTDLL to perform the NT system call. This means when a user launched a program it would indicate which subsystem to use and load all of its dependencies along with it based on the executable header. The predecessor to WSL, Subsystem for Unix-based Applications (SUA) was a replacement for POSIX, it was created to encourage developers to port their applications over by not having to worry about major rewrites to their code, instead, they implemented the POSIX user-mode APIs using NT constructs. However because the components were constructed in user mode, this model relied on the need for programs to be recompiled and required ongoing feature porting and was a maintenance burden.</p><p>Eventually, most of those initial subsystems were retired but the Windows NT kernel maintained the ability to support multiple subsystems.</p><h2 id="wsl1"><span class="mr-2">WSL1</span><a href="#wsl1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>WSL1 makes use of this ability by deploying a Linux Kernel Emulator Subsystem alongside the Win32 Subsystem. It is a collection of user-mode and kernel-mode components that give the ability to run native Linux ELF64 binaries to run on Windows. The main components are the LXSS Manager service which is a user-mode session manager service that handles the Linux instance life cycle. The Pico Processes that host the unmodified user mode Linux (e.g. /bin/bash). The Pico Provider Drivers (lxss.sys, lxcore.sys) emulates the Linux kernel by translating Linux system calls into WindowsNT system calls such as <code class="language-plaintext highlighter-rouge">fork()</code>. Again this was an emulated Linux kernel and not an actual Linux Kernel as shown below.</p><p><img data-src="/assets/img/posts//wsl1-architecture1.png" alt="wsl1-architecture1" data-proofer-ignore> <img data-src="/assets/img/posts//wsl1-architecture2.png" alt="wsl1-architecture2" data-proofer-ignore></p><h3 id="issues-with-wsl1-architecture"><span class="mr-2">Issues with WSL1 Architecture</span><a href="#issues-with-wsl1-architecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Because WLS1 architecture uses an emulated Linux Kernel as a subsystem and not a real kernel. Some system calls will not translate correctly to what windows expect, for example in the image below we see how renaming a directory while having a child file open is done on the Windows side vs the Linux side.</p><p>When Linux renames a directory it uses the open() syscall followed by the rename() syscall of the folder, allowing the folder to be moved underneath the file. However, the way Windows does this is by using the OpenFile() syscall followed by the MoveFile() syscall and it does not allow the underlying folder to be moved underneath. This will cause an ERROR_ACCESS_DENIED error. This is an example of many system calls that don’t translate correctly and therefore will not work using WSL1.</p><p><img data-src="/assets/img/posts//wsl1-renaming-folder.png" alt="wsl1-renaming-folder" data-proofer-ignore></p><h2 id="wsl2"><span class="mr-2">WSL2</span><a href="#wsl2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Because of this Microsoft decided to revamp WSL and ship a real Linux Kernel, making it work side by side with the Windows NT Kernel, this is a <a href="https://github.com/microsoft/WSL2-Linux-Kernel">specially tuned kernel</a> for WSL2 managed all in-house by Microsoft and updated via Windows Update. They have modified for it to boot up very quickly and removed many things that are not needed that the windows hypervisor handles. However their upstream is the same open-source kernel from <a href="https://www.kernel.org/">kernel.org</a>. As you see below when you enable the Virtualization Services feature on windows 10 it deploys both kernels on a thin layer on top of the Windows Hypervisor. This is a Type 1 Hypervisor and should not be confused with Hyper-V or Hyper-V Plattform which is the client that talks to the Windows Hypervisor. This way WSL2 uses Windows Hypervisor through Virtual Machine Platform to run both Windows and Linux in their own separate VM’s, this design allows WSL2 to use a genuine Linux kernel in a separate virtual machine that runs in parallel to the Windows NT kernel. These are not traditional VM’s however, there is no Isolation since the Linux VM and Windows VM are integrated systems.</p><p><img data-src="/assets/img/posts//wsl2-architecture1.png" alt="wsl2-architecture1" data-proofer-ignore> <img data-src="/assets/img/posts//wsl2-architecture-overview.png" alt="wsl2-architecture-overview" data-proofer-ignore> <img data-src="/assets/img/posts//wsl2-architecture-flow.png" alt="wsl2-architecture-flow" data-proofer-ignore></p><p>WSL2 is backed by Windows Hypervisor through Virtual Machine Platform deploying a “Lightweight Linux Utility VM” consisting of a Linux Kernel and a Linux instance allowing you to install different System Containers(not to be confused with Docker Containers or Application Containers) or distributions all isolated by Linux namespaces running on the same ext4 filesystem all within the same Lightweight Linux Utility VM.</p><p><img data-src="/assets/img/posts//wsl2-accessing-windows-files.png" alt="wsl2-accessing-windows-files" data-proofer-ignore> <img data-src="/assets/img/posts//wsl2-accessing-linux-files.png" alt="wsl2-accessing-windows-files" data-proofer-ignore> <img data-src="/assets/img/posts//wsl2-launching-windows-processes.png" alt="wsl2-launching-windows-processes" data-proofer-ignore> <img data-src="/assets/img/posts//wsl2-comlete-architecture-diagram.png" alt="wsl2-comlete-architecture-diagram" data-proofer-ignore></p><p>As you can see from the above image the method WSL2 mounts or makes the drives accessible is by deploying a client both on the distribution and the windows side, and also a server on the Linux distro and windows side using the 9P protocol. Almost like an NFS share. As you can see you can also start/manage windows programs using the same protocol in the case above it opens up the cmd.exe program.</p><h3 id="additional-features-over-wsl1"><span class="mr-2">Additional Features Over WSL1</span><a href="#additional-features-over-wsl1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>wsl2 uses a real Linux kernel shipped with windows, built using the Linux 4.19 kernelext4 root filesystem<li>/etc/wsl.conf - this is a configuration file that will allow you to add or remove features for wsl<li>wslpath - translates paths from one environment to the other<li>$WSLENV - share environment variables between Linux and windows</ul><p>NOTE: Although WSL2 gives us the ability to <a href="https://docs.microsoft.com/en-us/windows/wsl/build-custom-distro">build and distribute our own WSL2 distros</a>, Docker Desktop does not allow other distros to be used other than the one it ships with.</p><h1 id="docker-desktop-deep-dive">Docker Desktop Deep Dive</h1><p>Docker Desktop Deep Dive In the past Docker bundled all the functionality into the Docker daemon which made it bloated and centralized, this made the Docker daemon a central attack vector. This was later corrected and overhauled into separate components which makes it simpler to secure since each component can be handled and secured individually, this is what gave the ability for Docker to be ported over to desktops.</p><p>Docker communication is facilitated through the use of several API’s. The Docker Client itself communicates with the daemon through a domain(UNIX) socket, or remotely through a TCP socket. The commands are sent from the Docker client to the Docker Engine which then forwards the calls to Containerd. Communication between the Docker Dameonn and Conatinerd is facilitated through the gRPC ( remote procedure call protocol) protocol. Containerd utilizes a runtime specification, usually “runc” to create the actual containers.</p><p>Some changes were made in Docker Desktop 2.2.0</p><ul><li><a href="https://www.docker.com/blog/deep-dive-into-new-docker-desktop-filesharing-implementation/">FUSE</a>-based filesharing protocol within docker containers<li>Windows Hypervisor sockets instead of the Hyper-V networking<li>Runs with User privilege.<li>No need to authenticate or handle passwords<li>No need for IP or to manage addresses<li>Supports Caching and inotifiy<li>Kubernetes<li>WSL2 uses the latest stable Docker daemon<li>The ability to use vpnkit<li>The ability to use HTTP proxy settings and trusted CA</ul><p>In order to install and run Docker Desktop with a WSL2 backend, it is recommended to follow these instructions to install WSL2 then these instructions to install Docker Desktop and enable the WSL2 support. Since the installation wizard will see WSL2 is enabled and will install any applicable utilities needed.</p><p>There are two main ways to run Docker on Windows. The first method will be using Hyper-V as the backend which is the original method, it gives us a full isolated Linux VM but is very slow and will be deprecated in the near future. The second method is using WSL2 this is much faster given that it’s an integrated system and will more than likely be the defacto going forward.</p><h2 id="hyper-v-backend"><span class="mr-2">Hyper-V Backend</span><a href="#hyper-v-backend" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Docker on Desktop running on with a Hyper-V Backend is completely different than running on WSL2. The most important thing to note with this method is the Linux VM that ships with Docker for Hyper-V. This Linux VM is entirely built using <a href="https://github.com/linuxkit/linuxkit">LinuxKit</a>, Docker wrote a number of LinuxKit components, used both in Hyper-V and Mac VMs: services controlling the lifecycle of Docker and Kubernetes, services to collect diagnostics in case of failure, services aggregating logs, etc. Those services are packaged in an iso file in the Docker Desktop installation directory (docker-desktop.iso). On top of this base distro, at runtime, the second iso is mounted, which calls a version-pack iso. This file contains binaries and deployment/upgrade scripts specific to a version of the Docker Engine and Kubernetes. In the Enterprise edition, this second iso is part of the version packs docker publishes, while in the Community Editon, a single version pack is supported (the docker.iso file, also present in the docker desktop installation folder). Before starting the VM, a VHD is attached to store container images and configs, as well as the Kubernetes data store. To make those services accessible from the Windows side, Docker built a proxy that exposes Unix sockets as Windows <a href="https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes">named pipes</a>, using Hyper-V Sockets under the hood.</p><p><img data-src="/assets/img/posts//docker-desktop-hyperv-backend.png" alt="docker-desktop-hyperv-backend" data-proofer-ignore></p><h1 id="wsl2-backend">WSL2 Backend</h1><p>The WSL2 backend is very similar to the Hyper-V backend with the biggest change being that the Linuxkit Distro does not run as a VM but rather as a container itself(not a Docker/OCI container, rather containerized using namespaces). When we first install Docker Desktop with a WSL2 backend, the installation wizard will create two separate WSL Distributions. “Docker-desktop” which is referred to as the “Bootstrapping distro” essentially replacing Hyper-V and the “Docker-desktop-data” which is referred to as the “data store distro” also replacing what we would normally think of as our VHD.</p><p>The bootstrapping distro creates a Linux Namespace with its own root filesystem based on the Docker Desktop ISO and the Version Pack ISO files, then uses the “data store distro” as storage for container images, etc. Instead of a VHD, since WSL2 does not allow additional VHD’s to be other than the main one that is used for the Light Weight Linux Utility VM, cross-distro mounts are used instead.</p><p>One thing to note is because WSL2 comes with a Linux kernel and system services these have been taken out of the docker-desktop.iso file being used. The version-pack.iso file is identical to the Hyper-V(and Mac).</p><p>The Bootstrapping distro also manages things like mounting the Windows 9p shares in a place that can be accessed by the Linuxkit container and controls the lifecycle of the Linuxkit container ensuring things like a clean shutdown etc. This lets Docker run in a contained environment similar to the Hyper-V and Mac VM’s. so that no matter what backend Docker is using Hyper-V, WSL2, or Hyperkit for Macs the same code base is used for the Linuxkit components.</p><p>Some other benefits over Hyper-V are the time difference it takes to start docker containers, and because WSL2 uses dynamic resource allocations it can access all the resources of the machines and consume as much or as little as it needs. This makes it easier to run in environments with lower memory where it was previously difficult to allocate 2GB of ram for Hyper-V upfront, this also allows for support in Windows versions where Hyper-V is not available such as Windows Home edition.</p><p><img data-src="/assets/img/posts//docker-desktop-wsl2-backend.png" alt="docker-desktop-wsl2-backend" data-proofer-ignore></p><p>NOTE: As stated above although we have the ability to create our own WSL2 Distros, Docker Desktop will not let use our own.</p><h2 id="vpnkit"><span class="mr-2">VPNKIT</span><a href="#vpnkit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><img data-src="https://raw.githubusercontent.com/moby/vpnkit/master/docs/vpnkit.svg" alt="vpnkit" data-proofer-ignore></p><p>The Docker for Windows VM is running on top of Hyper-V. vpnkit on the host uses Hyper-V sockets to connect to a process (tap-vsockd) inside the VM which accepts the connection and configures a tap device. Frames are encapsulated using the same custom protocol as on the Mac.</p><p><img data-src="https://raw.githubusercontent.com/moby/vpnkit/master/docs/win.svg" alt="vpnkit2" data-proofer-ignore></p><p>Frames arriving from the VM are processed by a simple internal ethernet switch. The switch demultiplexes traffic onto output ports by matching on the destination IPv4 address. Frames that don’t match any rule are forwarded to a default port.</p><p>Frames arriving on the default port are examined and if they contain ARP requests, we send a response using a static global ARP table if they contain IPv4 datagrams then we create a fresh virtual TCP/IP endpoint using the Mirage TCP/IP stack (no kernel TCP/IP interfaces are involved), a fresh switch port on our internal switch, and connect them together so that all future IPv4 traffic to the same destination address is processed by the new endpoint. Each virtual TCP/IP endpoint terminates TCP and UDP flows using the Mirage TCP/IP stack. The data from the flows is proxied to and from regular BSD-style sockets on both Windows and Mac. The host kernel therefore only sees outgoing SOCK_STREAM and SOCK_DGRAM connections from the vpnkit process.</p><p>If the VM is communicating with 10 remote IP addresses, then there will be 10 instances of a Mirage TCP/IP stack, one per IP address. The TCP/IP stack instances act as proxies for the remote hosts.</p><p>The following diagram shows the flow of ethernet traffic within VPNKit:</p><p><img data-src="https://raw.githubusercontent.com/moby/vpnkit/master/docs/ethernet.svg" alt="vpnkit2" data-proofer-ignore></p><p>Each switch port has an associated last_active_time and if there is no traffic flow for a configured time interval, the port is deactivated and the TCP/IP endpoint is shutdown.</p><p>The active ports may be queried by connecting to a Unix domain socket on the Mac or a named pipe on Windows and receiving diagnostic data in a Unix tar formatted stream.</p><p>What happens when an application inside a container in the Linux VM tries to make a TCP connection:</p><ul><li>the application calls connect<li>the Linux kernel emits a TCP packet with the SYN flag set<li>the Linux kernel applies the iptables rules and consults the routing table to select the outgoing interface and then transmits the frame<li>the frame is relayed to the host<li>the interface was a tap device created by the tap-vsockd process. This process reads the frame from the associated file descriptor, encapsulates it and writes it to the Hyper-V socket connected to vpnkit.<li>the frame is received by vpnkit and input into the ethernet switch.<ul><li>if the destination IP is not recognised: vpnkit creates a TCP/IP endpoint using <a href="https://mirage.io/">Mirage</a> <a href="https://github.com/mirage/mirage-tcpip">TCP/IP</a> stack with the destination IP address and configures the switch to send future packets with this destination IP to this endpoint<li>if the destination IP is recognised: the internal switch inputs the frame into the TCP/IP endpoint</ul><li>the TCP/IP endpoint observes the SYN flag is set and so it calls the regular connect API to establish a regular SOCK_STREAM connection to that destination.<ul><li>if the connect succeeds: the TCP/IP endpoint sends back a packet with the SYN and ACK flags set and the handshake continues<li>if the connect fails: the TCP/IP endpoint sends back a packet with the RST flag set to reject the connection.</ul></ul><p>If all has gone well, the VM now has a TCP connection over a virtual point-to-point ethernet link connected to vpnkit, and vpnkit has a socket connection to the true destination. vpnkit will now proxy the data in both directions.</p><p>Note that from the host kernel’s point of view, there is no network connection to the VM and no set of associated firewall rules or routing tables. All outgoing connections originate from the vpnkit process. If the user installs some advanced networking or VPN software which reconfigures the routing table or firewall rules, it will not break the connection between vpnkit and the VM.</p><p>This technique for forwarding network connections is commonly known as <a href="https://en.wikipedia.org/wiki/Slirp">Slirp</a>.</p><h1 id="docker-desktop-security-considerations-and-securing-docker-desktop">Docker Desktop Security Considerations and Securing Docker Desktop</h1><p>We have decided to use Docker Desktop with a WSL2 backend. Because of this the rest of the document will only speak to Docker Desktop with a WSL2 Backend using the Docker provided WSL2 Distrbitutions.</p><h2 id="non-docker-specific-considerations"><span class="mr-2">Non-Docker Specific Considerations</span><a href="#non-docker-specific-considerations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As of Windows 10, 1803 and later “lxrun.exe” has been deprecated. It was used to set up and configure the Linux distributions that were installed in WSL. It was in this configuration that we were forced to set up a username and password for the distro as to not run as a root inside the distro from the get-go. However, there seems to be a flaw when deploying a distribution, when the system is determining the UNIX user and password. If the terminal associated with the deployment is terminated during the initial operation there is no defined user set and instead, the default process is to access the root account without credentials. Effectively replicating the automated setup for the default root user that is normally generated with “lxrun.exe”. By running a termination loop during the configuration you are guaranteed that WSL access is at the root level every time.</p><p>However, for installing or running any sort of persistence method the attacker must run either the “bash.exe”, “wsl.exe” or distro-specific “.exe” such as “kali.exe”. Which in turn creates a “C:\Windows\system32\lxss\wslhost.exe” binary to command and/or initiate the WSL instance. It is not possible to automatically run the WSL instance by starting the associated services automatically, which means these binaries need to be called in order for it to start. Today the Linux instance is not configured with the ability for an automated service initiation system such as “init” or “systemd”.So any payloads which need persistence must be implemented through a windows level mechanism which should be able to be detected by our monitoring tools and processes.</p><p>Another observation should be made that the WSL2 is set to terminate itself after 1 minute if no actions or processes are running on it. For example, if a user runs some processes or scripts and then terminates the shell or session, Windows Hypervisor will wait one minute and then terminate it. However, if a background process is running on the subsystem instance then it will not terminate and run for as long as the process or service is active.</p><p>Because WSL2 is an integrated system WSL2 by default mounts the entire C drive and makes it accessible from within the Linux Distribution, because of this you are able to create, edit, and delete files from within the Linux distro. However, it does seem that even though you are root inside the distro without some sort of privilege escalation you cannot create or modify files and directories which you do not have access to on the Windows side.</p><p><strong>Here I am an admin on the windows machine creating a file from within the Distro inside WSL2.</strong></p><p><img data-src="/assets/img/posts//docker-desktop-file-made-in-linux.png" alt="docker-desktop-file-made-in-linux" data-proofer-ignore></p><p><strong>Here I am an admin on the windows machine creating a file from within Windows and it’s accessible within WSL2.</strong></p><p><img data-src="/assets/img/posts//docker-desktop-file-made-in-windows.png" alt="docker-desktop-file-made-in-windows" data-proofer-ignore></p><p><strong>Here I am a regular user on the windows machine but root from within the Distro inside WSL2.</strong></p><p><img data-src="/assets/img/posts//docker-desktop-regular-user-files.png" alt="docker-desktop-regular-user-files.png" data-proofer-ignore></p><p><strong>By default, this is everything mounted on any WSL2 distro.</strong></p><p><img data-src="/assets/img/posts//docker-desktop-default-mounts.png" alt="docker-desktop-default-mounts" data-proofer-ignore></p><p>Knowing that the system is an integrated system gives us access to root level controls and directories, and the fact that most of the installation and system deployment of WSL need almost no input from the user or attacker and can be automated. Once it is installed the attacker will have full access to the subsystem without the user being alerted or notified of anything running in the background. Because the WSL2 instance is contained in the Linux System Container and runs all its calls through its own kernel none of our Windows EDR tools such as Carbon Black, will pick it up since they are only looking for specific files on the system or executables running, but the only real executable and services running are the “.exe” specific binaries and “wslhost.exe”, there is also no Event tracing for Windows output as well. This will give an attacker a fully customizable foothold within our network. Since there is no way to detect or discern an attacker running a service vs a legitimate user running a service.</p><h2 id="docker-specific-considerations"><span class="mr-2">Docker Specific Considerations</span><a href="#docker-specific-considerations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><img data-src="/assets/img/posts//docker-desktop-whoami.png" alt="docker-desktop-whoami" data-proofer-ignore></p><p>Docker specific consideration from a WLS2 point of view is that the distribution of docker that comes with Docker desktop by default only has the <code class="language-plaintext highlighter-rouge">root</code> user. And even if the user itself does not have privileges on the WSL2 side, from inside the container since the WSL drive is mounted the root user in the container can create modify, and write files directly to the windows side of the filesystem.</p><p>Here I am running a vulnerable container so I am taking the stance that either I have already have gotten root by privilege escalation or that only the root user exists on the container. As you can see from inside the container I am able to access the C drive that is mounted on the WSL part and even though I can’t access the <code class="language-plaintext highlighter-rouge">TamaleRhino</code> user or admin user I can still create documents under specific folders including the docker.socket which would let me make API calls directly to the Docker daemon itself.</p><p><img data-src="/assets/img/posts//docker-desktop-directories.png" alt="docker-desktop-directories" data-proofer-ignore> <img data-src="/assets/img/posts//docker-desktop-dockersock.png" alt="docker-desktop-dockersock" data-proofer-ignore></p><h2 id="securing-docker-desktop"><span class="mr-2">Securing Docker Desktop</span><a href="#securing-docker-desktop" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>When it comes to Docker best practices there are a few categories to look at, I will break them up as follows. The Host(this is really the WSL2 side of the host since it’s integrated with windows) the Docker Daemon and the Containers themselves.</p><h3 id="host"><span class="mr-2">Host:</span><a href="#host" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="files"><span class="mr-2">Files:</span><a href="#files" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>From a DRT perspective WSL can be tricky to detect and, even if detected, the malicious association can be extremely difficult. As the installation of such a component is not in itself malicious, we are required to focus on the context of its deployment on a host as well as the distribution that is selected. Because a binary is created when a distribution is downloaded or installed we should be monitoring and blocking any of the standard WSL images such as “kali.exe”, “ubuntu.exe”, “centos” etc. under <code class="language-plaintext highlighter-rouge">C:\Users\&lt;user&gt;\AppData\Local\Microsoft\WindowsApps\</code> and only allow the Docker-based distributions. Another place would be the registry itself. Anytime there is an instance deployed on the system, the configuration information for it can be found with unique identifiers under the following registry location <code class="language-plaintext highlighter-rouge">Computer\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Lxss</code></p><p><img data-src="/assets/img/posts//regex-docker-data.png" alt="regex-docker-data" data-proofer-ignore> <img data-src="/assets/img/posts//regex-docker-desktop.png" alt="regex-docker-desktop" data-proofer-ignore></p><p>This provides an easy location to check for the distro installed as well as the location if an attacker wants to use a different location other than what is standard.</p><h4 id="services"><span class="mr-2">Services:</span><a href="#services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>When it comes to services running it is really hard to know what is legitimate and what is not since the same services are used no matter what and from the Windows point of view it’s just a standard service.</p><p>The main service to look out for is the lxssmanager it is the main one that starts up whenever you start a WSL distro. and if this service is terminated all the associated WSL instances are also terminated. The lxssmanager service triggers two svchost.exe instances one acting as a COM surrogate and the other to execute wslhost.exe which runs for as long as the WSL instance is running. The terminal session the user initiates also creates another wslhost.exe instance as a subprocess for the terminal being used ie: Powershell, under a wsl.exe. By checking to see that wslhost.exe and lxssmanager services are running we can detect whether wsl2 is running on the system.</p><p>Because WSL2 runs on an instance with its own kernel it has no visible services on the windows side, and no logging(for WSL) like wsl1 had it makes it near impossible to monitor services inside the WSL2 instance.</p><p>However, this is where a <a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig">WSL Config</a> file would come into play, the <code class="language-plaintext highlighter-rouge">.wslconfig</code> file usually located in <code class="language-plaintext highlighter-rouge">C:\Users\&lt;yourUserName&gt;\.wslconfig</code> will help us set different settings for WSL2 such as resource limits, what kernel we can use, what ports can be used and any additional kernel command line arguments we want to use when the instance initializes. Other options include creating a specific <a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config#configure-per-distro-launch-settings-with-wslconf"><code class="language-plaintext highlighter-rouge">/etc/wsl.conf</code></a> that will let us control what filesystems or folders are automounted, Network options, what Users can be used on the system, and even if they have the ability to launch windows programs for example by creating a wsl.conf file with the <code class="language-plaintext highlighter-rouge">interop</code> label the key <code class="language-plaintext highlighter-rouge">enabled</code> set to <code class="language-plaintext highlighter-rouge">false</code> the user will not be able to launch windows processes. additionally setting the <code class="language-plaintext highlighter-rouge">appendWindowsPath</code> to <code class="language-plaintext highlighter-rouge">false</code> will not add Windows path elements to the <code class="language-plaintext highlighter-rouge">$PATH</code> environment variable.</p><p>There is also an experimental <code class="language-plaintext highlighter-rouge">boot</code> label that lets us run a command, we might be able to use this as some sort of hook or way to get logging out of the WSL instance into the windows machine for better monitoring.</p><p>NOTE: Again because docker desktop does not allow us to use our own distros. In order to create a <code class="language-plaintext highlighter-rouge">/etc/wsl.conf</code> file, we will have to do it after the fact, either through some sort of script that creates the file from the Windows side, or a script on the Docker side.</p><h3 id="docker-daemon"><span class="mr-2">Docker Daemon</span><a href="#docker-daemon" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="apisyscalls"><span class="mr-2">API/Syscalls:</span><a href="#apisyscalls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>By default, a UNIX domain socket (or IPC socket) is created at /var/run/docker.sock, requiring either root permission or docker group membership.</p><p>A <a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file">daemon.json</a> file must be created for us to manage the docker daemon. The JSON file can be located at <code class="language-plaintext highlighter-rouge">%programdata%\docker\config\daemon.json</code> or in the Docker Desktop GUI under Settings → Docker Engine.</p><details> <summary>Full example of the allowed configuration options on Windows</summary><figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
  </span><span class="nl">"allow-nondistributable-artifacts"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"authorization-plugins"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"bridge"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"cluster-advertise"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"cluster-store"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"containerd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"</span><span class="se">\\\\</span><span class="s2">.</span><span class="se">\\</span><span class="s2">pipe</span><span class="se">\\</span><span class="s2">containerd-containerd"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"containerd-namespace"</span><span class="p">:</span><span class="w"> </span><span class="s2">"docker"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"containerd-plugin-namespace"</span><span class="p">:</span><span class="w"> </span><span class="s2">"docker-plugins"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"data-root"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"debug"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nl">"default-ulimits"</span><span class="p">:</span><span class="w"> </span><span class="p">{},</span><span class="w">
  </span><span class="nl">"dns"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"dns-opts"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"dns-search"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"exec-opts"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"experimental"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
  </span><span class="nl">"features"</span><span class="p">:</span><span class="w"> </span><span class="p">{},</span><span class="w">
  </span><span class="nl">"fixed-cidr"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"hosts"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"insecure-registries"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"labels"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"log-driver"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"log-level"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"max-concurrent-downloads"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
  </span><span class="nl">"max-concurrent-uploads"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
  </span><span class="nl">"max-download-attempts"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
  </span><span class="nl">"mtu"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
  </span><span class="nl">"pidfile"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"raw-logs"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
  </span><span class="nl">"registry-mirrors"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"shutdown-timeout"</span><span class="p">:</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w">
  </span><span class="nl">"storage-driver"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"storage-opts"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
  </span><span class="nl">"swarm-default-advertise-addr"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"tlscacert"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"tlscert"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"tlskey"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"tlsverify"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span></code></pre></figure></details><p>Apparmor is not available for Docker Desktop and <code class="language-plaintext highlighter-rouge">seccomp-profile</code> is not an option on the windows daemon.json. However, when running <code class="language-plaintext highlighter-rouge">docker system info</code> it does mention it is using a <a href="https://docs.docker.com/engine/security/seccomp/#significant-syscalls-blocked-by-the-default-profile">default profile</a>, it seems we just can’t change it.</p><p><img data-src="/assets/img/posts//docker-system-info.png" alt="docker-system-info" data-proofer-ignore></p><p>We can however use an <a href="https://docs.docker.com/engine/extend/plugins_authorization/">Authorization Plugin</a>. By default Docker’s out-of-the-box authorization model is all or nothing. Any user with permission to access the Docker daemon can run any Docker client command. The same is true for callers using Docker’s Engine API to contact the daemon. An authorization plugin approves or denies requests to the Docker daemon based on both the current authentication context and the command context. The authentication context contains all user details and the authentication method. The command context contains all the relevant request data.</p><p>We should use an auth plugin such as <a href="https://www.openpolicyagent.org/docs/v0.11.0/docker-authorization/">Open Policy Agent</a> or <a href="https://github.com/twistlock/authz">Twistlock</a> to get the granular controls needed.</p><h3 id="logging"><span class="mr-2">Logging:</span><a href="#logging" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Logging for docker containers can be found under <code class="language-plaintext highlighter-rouge">C:\Users\&lt;user&gt;\AppData\Local\Docker</code>.</p><p><img data-src="/assets/img/posts//docker-desktop-log-folder.png" alt="docker-desktop-log-folder" data-proofer-ignore></p><p>The Docker daemon logs two types of events:</p><ul><li>Commands sent to the daemon through Docker’s Remote API<li>Events that occur as part of the daemon’s normal operation</ul><h4 id="remote-api-events"><span class="mr-2">Remote API Events</span><a href="#remote-api-events" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>The <a href="https://docs.docker.com/engine/reference/api/docker_remote_api/">Remote API</a> lets you interact with the daemon using common commands. Commands passed to the Remote API are automatically logged along with any warning or error messages resulting from those commands. Each event contains:</p><ul><li>The current timestamp<li>The log level (Info, Warning, Error, etc.)<li>The request type (GET, PUT, POST, etc.)<li>The Remote API version<li>The endpoint (containers, images, data volumes, etc.)<li>Details about the request, including the return type For example, listing the active containers on a Boot2Docker host generates the following log entry: <code class="language-plaintext highlighter-rouge">time="2015-11-18T11:28:50.795661833-05:00" level=info msg="GET /v1.21/containers/json"</code></ul><h4 id="daemon-events"><span class="mr-2">Daemon Events</span><a href="#daemon-events" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Daemon events are messages regarding the state of the Docker service itself. Each event displays:</p><ul><li>The current timestamp<li>The log level<li>Details about the event<li>The events recorded by the daemon provide detailed information on:</ul><p>Actions performed during the initialization process</p><ul><li>Features provided by the host kernel<li>The status of commands sent to containers<li>The overall state of the Docker service<li>The state of active containers Daemon events often provide detailed information about the state of containers. However, messages regarding a container may refer to the container by ID rather than by name. For instance, a container with the name “sleepy_nobel” failed to respond to a stop command. The stop command, along with the failure notification, generated the following events: <code class="language-plaintext highlighter-rouge">time="2015-11-18T11:28:40.726969388-05:00" level=info msg="POST /v1.21/containers/sleepy_nobel/stop?t=10"</code> <code class="language-plaintext highlighter-rouge">time="2015-11-18T11:28:50.754021339-05:00" level=info msg="Container b5e7de70fa9870de6c3d71bf279a4571f890e246e8903ff7d864f85c33af6c7c failed to exit within 10 seconds of SIGTERM - using the force"</code> You can retrieve a container’s ID by using the <code class="language-plaintext highlighter-rouge">docker inspect</code> command. Example of docker log.</ul><p><img data-src="/assets/img/posts//docker-desktop-example-log1.png" alt="docker-desktop-example-log1" data-proofer-ignore> <img data-src="/assets/img/posts//docker-desktop-example-log2.png" alt="docker-desktop-example-log1" data-proofer-ignore></p><h2 id="containers-and-images"><span class="mr-2">Containers and Images</span><a href="#containers-and-images" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Although we will be limiting the Docker Desktop program to use authorized docker hubs only. There is a use case where the developer can recreate a vulnerable container and be able to share it quite easily.</p><p>The developer will have to create a dockerfile(or download from places like GitHub) that will build a vulnerable container locally. All they would have to do is download the scripts they want to run to configure the vulnerable container and create a docker file to use them.</p><p>The base image would be downloaded from our internal secure source such as our MCR, and then through the build process of their dockerfile the vulnerable docker image would be created. This is a flat file that can be zipped up and shared rather easily either through emailing directly or using our internal tools such as Bitbucket and confluence. It is because of this that we should consider the container hostile at all times and most of our controls should be focused on the host itself, wsl platform, and docker engine to give us that defense in depth needed to mitigate the risk of hostile containers.</p><h1 id="sources">Sources</h1><ul><li>https://www.youtube.com/watch?v=lwhMThePdIo<li>https://docs.microsoft.com/en-us/windows/wsl/compare-versions<li>https://docs.microsoft.com/en-us/archive/blogs/wsl/windows-subsystem-for-linux-overview<li>https://www.docker.com/blog/new-docker-desktop-wsl2-backend/<li>https://levelup.gitconnected.com/docker-desktop-on-wsl2-the-problem-with-mixing-file-systems-a8b5dcd79b22<li>https://www.docker.com/blog/deep-dive-into-new-docker-desktop-filesharing-implementation/<li>https://docs.microsoft.com/en-us/windows/wsl/install-win10<li>https://docs.docker.com/docker-for-windows/wsl/<li>https://docs.microsoft.com/en-us/windows/wsl/<li>https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-containers<li>https://medium.com/swlh/building-a-dev-container-for-net-core-e43a2236504f<li>https://devblogs.microsoft.com/commandline/learn-about-windows-console-and-windows-subsystem-for-linux-wsl/<li>https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes<li>aka.ms/cliblog<li>https://github.com/Microsoft/WSL<li>https://docs.microsoft.com/en-us/windows/wsl/build-custom-distro<li>https://github.com/linuxkit/linuxkit<li>https://img.en25.com/Web/FSecure/%7B87c32f0e-962d-4454-b244-1bb8908968d4%7D_WSL-2-RESEARCH.pdf<li>https://www.cvedetails.com/product/28125/Docker-Docker.html?vendor_id=13534<li>https://www.loggly.com/blog/what-does-the-docker-daemon-log-contain/<li>https://superuser.com/questions/1556521/virtual-machine-platform-in-win-10-2004-is-hyper-v/1619173#1619173<li>https://www.docker.com/blog/capturing-logs-in-docker-desktop/</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/containerization/'>Containerization</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/containerization/" class="post-tag no-text-decoration" >containerization</a> <a href="/tags/wsl/" class="post-tag no-text-decoration" >wsl</a> <a href="/tags/wsl2/" class="post-tag no-text-decoration" >wsl2</a> <a href="/tags/docker/" class="post-tag no-text-decoration" >docker</a> <a href="/tags/docker-desktop/" class="post-tag no-text-decoration" >docker desktop</a> <a href="/tags/windows/" class="post-tag no-text-decoration" >windows</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Docker+Desktop+WSL2+Deep+Dive+-+Tamalerhino%27s+Blog&url=https%3A%2F%2Ftamalerhino.github.io%2Fposts%2Fdocker-desktop-wsl2-deep-dive%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Docker+Desktop+WSL2+Deep+Dive+-+Tamalerhino%27s+Blog&u=https%3A%2F%2Ftamalerhino.github.io%2Fposts%2Fdocker-desktop-wsl2-deep-dive%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Ftamalerhino.github.io%2Fposts%2Fdocker-desktop-wsl2-deep-dive%2F&text=Docker+Desktop+WSL2+Deep+Dive+-+Tamalerhino%27s+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/container-from-scratch/">Containers From Scratch Part 1</a><li><a href="/posts/systemd-namespace-containers/">Systemd Namespace Containers</a><li><a href="/posts/docker-debian-airgapped/">Install Docker Air Gapped</a><li><a href="/posts/docker-desktop-wsl2-deep-dive/">Docker Desktop WSL2 Deep Dive</a><li><a href="/posts/how-to-abuse-container-repositories-for-fun-and-profit/">How To Abuse Container Repositories For Fun And Profit</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/containerization/">containerization</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/docker-desktop/">docker desktop</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/wsl2/">wsl2</a> <a class="post-tag" href="/tags/wsl/">wsl</a> <a class="post-tag" href="/tags/data-exfiltration/">data exfiltration</a> <a class="post-tag" href="/tags/devsecops/">devsecops</a> <a class="post-tag" href="/tags/dlp/">dlp</a> <a class="post-tag" href="/tags/hacking/">hacking</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/creating-a-custom-wsl2-image/"><div class="card-body"> <em class="small" data-ts="1636650000" data-df="ll" > Nov 11, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Creating A Custom WSL2 Image</h3><div class="text-muted small"><p> Recently with the usage of Docker Desktop, there has been a need to use WSL2 to run Docker Desktop on Windows. However because of the various security implications, missing security kernel modules,...</p></div></div></a></div><div class="card"> <a href="/posts/docker-debian-airgapped/"><div class="card-body"> <em class="small" data-ts="1657990800" data-df="ll" > Jul 16, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Install Docker Air Gapped</h3><div class="text-muted small"><p> As part of a competition i am taking part of i needed the ability to run a simple self hosted wiki page on my Kali box. the fastest and best alternative was to run this as a container. Although i t...</p></div></div></a></div><div class="card"> <a href="/posts/how-to-abuse-container-repositories-for-fun-and-profit/"><div class="card-body"> <em class="small" data-ts="1635008400" data-df="ll" > Oct 23, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How To Abuse Container Repositories For Fun And Profit</h3><div class="text-muted small"><p> Often as security engineers we are worried about what vulnerabilites can be downloaded from container registries, howver i believe the same could be used to exfiltrate data. We will go over what a...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"><div class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></div><a href="/posts/how-to-abuse-container-repositories-for-fun-and-profit/" class="btn btn-outline-primary" prompt="Newer"><p>How To Abuse Container Repositories For Fun And Profit</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/tamalerhino">Ulises Galeano</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/containerization/">containerization</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/docker-desktop/">docker desktop</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/wsl2/">wsl2</a> <a class="post-tag" href="/tags/wsl/">wsl</a> <a class="post-tag" href="/tags/data-exfiltration/">data exfiltration</a> <a class="post-tag" href="/tags/devsecops/">devsecops</a> <a class="post-tag" href="/tags/dlp/">dlp</a> <a class="post-tag" href="/tags/hacking/">hacking</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
